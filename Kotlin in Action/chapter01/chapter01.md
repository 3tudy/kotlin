# 1장 코틀린이란 무엇이며, 왜 필요한가

## 1.1 코틀린 맛보기

```kotlin
data class Person(val name: String,     // "데이터" 클래스
                 val age: Int? = null)  // null이 될 수 있는 타입(Int?)과 파라미터 디폴트 값

fun main(args: Array<String>) {         // 최상위 함수
    val persons = listOf(Person("영희"),
                        Person("철수", age=29)) // 이름 붙은 파라미터
    val oldest = persons.maxBy { it.age ?: 0}   // lambda expression과 Elvis operator
    println("나이가 가장 많은 사람: $oldest")   // 문자열 템플릿
}

//>> 나이가 가장 많은 사람: Person(name=철수, age=29)   // toString 자동 생성
```

Points

1. 영희는 나이를 지정하지 않았기에 `null`이 대신 쓰인다
2. 리스트에서 나이가 가장 많은 사람을 찾기 위해 `maxBy` 함수를 사용한다
3. `maxBy` 함수에 전달한 **lambda expression**은 파라미터를 하나 받는다
4. `it`이라는 이름을 사용하면 별도로 파라미터 이름을 정의하지 않아도 **lambda expression**의 유일한 인자를 사용할 수 있다
5. **Elvis operator**라고 부르는 `?:`는 `age`가 `null`인 경우 0을 반환, 그렇지 않으면 `age`의 값을 반환한다
6. 영희의 나이는 `null`이지만 **Elvis operator**가 `null`을 0으로 변환해 `age`를 비교할 수 있다

## 1.2 코틀린의 주요 특성

### 1.2.1 대상 플랫폼: 서버, 안드로이드 등 자바가 실행되는 모든 곳

> 코틀린의 주목적은 현재 자바가 사용되고 있는 모든 용도에 적합하면서도 더 간결하고 생산적이며 안전한 대체 언어를 제공하는것

1. 서버상의 코드(e.g. 웹 애플리케이션의 백엔드)
2. 안드로이드 디바이스에서 실행되는 모바일 애플리케이션
3. 인텔의 멀티OS 엔진위의 iOS 디바이스
4. 데스크탑 애플리케이션 (with TornadoFX, JavaFX)
5. 브라우저 (with JavaScript)

### 1.2.2 정적 타입 지정 언어

Kotlin은 정적 타입 지정언어

#### 정적 타입(Statically typed)

1. 모든 프로그램 구성 요소의 *타입*을 **컴파일 시점**에 알 수 있다
2. 프로그램 안에서 객체의 *필드*나 *메소드*를 사용할 때마다 **컴파일러가 타입을 검증해준다**

#### 동적 타입(Dynamically typed)

1. *타입*과 **관계없이** 모든 값을 변수에 넣을 수 있다
2. *메소드*나 *필드* 접근에 대한 검증이 **실행 시점**에 일어남

#### 타입 추론(Type Inference)

컴파일러가 문맥을 고려해 변수 타입을 결정하는 기능

#### Kotlin의 타입 시스템

1. Class
2. Interface
3. Generics
4. 널이 될 수 있는 타입(Nullable type)
    - 컴파일 시점에 *null pointer exception*을 체크할 수 있어 프로그램의 신뢰성을 높일 수 있다
5. **함수 타입**

### 1.2.3 함수형 프로그래밍과 객체지향 프로그래밍

### 함수형 프로그래밍

1. **First-class 함수**
   - 함수를 일반 값처럼
   - as a thing stored in variables, as an argument, as wrapper function
2. **불변성(Immutability)**
   - 불변 객체를 사용
   - 불변 객체: 일단 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 객체
   - *Q. 불변 객체의 예는 어떤 것들이 있을까?*
3. **부수 효과(side effect) 없음**
   - 입력이 같으면 항상 같은 출력
   - 다른 객체의 상태를 변경하지 않음
   - 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수를 사용

## 1.3 코틀린 응용

### 1.3.1 코틀린 서버 프로그래밍

서버 프로그래밍에서의 Kotlin의 장점

1. 자바 코드와 매끄럽게 상호운용을 할 수 있다
2. 1.의 장점을 이용해 기존의 자바 프레임워크나 기술을 Kotlin으로 확장하여 사용이 가능하다
3. Kotlin의 **Builder pattern**과 같은 Kotlin의 새로운 기술을 활용할 수 있다
   - DSL
   - HTML을 Kotlin으로 구현할 수 있다
   - SQL 쿼리도 Kotlin의 언어로 구현할 수 있다

#### DSL(Domain Specific Language)

1. *Q. 도메인은 어떤 것인가?*
   - 혼자 생각해본 답변
   - 벡엔드, 프론트엔드, 안드로이드와 같은 기술적 도메인
   - 결제, 주문과 같은 기능적 도메인
2. *Q. 각 도메인에 어울리는 언어는 어떤 것들이 있을까?*

### 1.3.2 코틀린 안드로이드 프로그래밍

모바일 애플리케이션의 특징

1. 기존의 엔터프라이즈 어플리케이션보다 더 작다
2. 기존 코드 기반과 새 코드를 통합할 필요도 더 적다
3. 더 다양한 디바이스에 대해 서비스의 신뢰성을 보장해야한다
4. 더 빠르게 개발해 배포해야한다

모바일 애플리케이션에서 Kotlin을 사용할 때의 장점

1. Kotlin의 특성과 안드로이드 프레임워크의 특별한 컴파일러 플러그인 지원의 조합
   1. 컨트롤에 리스너를 추가, 레이아웃 요소를 필드와 바인딩하는 등의 흔한 안드로이드의 개발 작업을 훨씬 더 적은 코드로 달성 가능
2. 애플리케이션의 신뢰성이 높아진다
   1. Kotlin의 타입 시스템이 null 값을 정확하게 추적할 수 있게하여 null pointer로 생기는 문제를 줄여준다
3. Java 6와 완전히 호환된다
4. 성능 측면에서 아무런 손해가 없다
   1. Kotlin 컴파일러가 생성한 *바이트 코드*는 일반적인 자바 코드와 똑같이 효율적
   2. 대부분의 Kotlin 표준 라이브러리 함수는 *lambda* 함수를 *inlining*한다
      - 람다를 사용해도 새로운 객체가 만들어지지 않아 Garbage Collection이 늘어나 프로그램이 자주 멈추지 않는다

## 1.4 코틀린의 철학

> Kotlin은 자바와의 **상호운용성**에 초점을 맞춘 **실용적**이고 **간결**하며 **안전**한 언어

### 1.4.1 실용성

1. 실무자들이 만든 언어이기에 연구를 위한 언어가 아니다
2. 다른 프로그래밍 언어가 채택한 이미 성공적으로 검증된 해법과 기능에 의존한다
3. 특정 프로그래밍 스타일이나 패러다임을 사용할 것은 강제하지 않는다
4. 도구를 강조한다

### 1.4.2 간결성

> 어떤 언어가 간결하다는 말은 그 언어로 작성된 코드를 읽을 때 **의도**를 쉽게 파악할 수 있는 **구문 구조를 제공**하고, 그 의도를 달성하는 방법을 이해할 때 방해가 될 수 있는 부가적인 준비 코드가 적다는 뜻이다.

1. 묵시적으로 제공되는 getter, setter, 생성자 파라미터 필드 등의 요소들
2. 다양한 표준 라이브러리 함수

### 1.4.3 안정성

1. JVM에서 Kotlin을 실행한다
   1. 메모리 안정성 보장
   2. 버퍼 오버플로를 방지
   3. 동적으로 할당한 메모리를 잘못 사용함으로 인해 발생할 수 있는 다양한 문제 예방
   4. 애플리케이션의 타입 안정성 보장
2. `?` 한 글자로 null이 될 수 있는지 여부를 표기할 수 있다

   ```kotlin
   val s: String? = null   // null이 될 수 있음
   val s2: String = ""     // null이 될 수 없음
   ```

3. null이 될 수 있는 값을 다룰 수 있는 편리한 방법을 다양하게 제공

### 1.4.4 상호운용성

1. 자바와 코틀린 코드를 원하는 대로 섞어서 사용할 수 있다
2. 기존의 라이브러리를 사용할 수 있다

## 1.5 코틀린 도구 사용

### 1.5.1 코틀린 코드 컴파일

1. `.kt`라는 확장자를 파일에 붙여 코틀린 소스코드를 저장한다
2. 코틀린 컴파일러는 `.kt` 파일을 분석해 `.class` 파일로 만들어낸다
3. `.class` 파일은 `$ kotlinc` 명령을 통해 코틀린 코드를 컴파일한 다음 java 명령으로 그 코드를 실행한다

   ```command
   // .class 파일 생성
   $ kotlinc <소스파일 또는 디렉터리> -include-runtime -d <jar 이름>
   // java 명령어로 코드 실행
   $ java -jar <jar 이름>
   ```
